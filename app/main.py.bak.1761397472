import psycopg, os, datetime as dt
from fastapi import FastAPI, HTTPException, Header, Request, Query
from fastapi.responses import HTMLResponse, RedirectResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from pydantic import BaseModel
import os

from db import init_db
from auth import (
    get_user_by_email, verify_password, create_access_token, decode_token, get_user_by_id
)
from settings import INTERNAL_TOKEN
from scoring import recompute_daily
from sources.bodacc import collect as bodacc_collect

app = FastAPI(title="Radar FR - MVP")

# Static & templates
app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

@app.get("/", response_class=HTMLResponse)
def root():
    return RedirectResponse(url="/login")

@app.get("/login", response_class=HTMLResponse)
def login_page(request: Request):
    return templates.TemplateResponse("login.html", {"request": request, "app_name": "Radar FR"})

@app.get("/documents", response_class=HTMLResponse)
def documents_page(request: Request):
    return templates.TemplateResponse("documents.html", {"request": request, "app_name": "Radar FR"})

@app.get("/healthz")
def healthz():
    return {"ok": True, "env": {"DB_URL_set": bool(os.getenv("DB_URL")), "port": os.getenv("PORT", "8080")}}

@app.post("/admin/init-db")
def admin_init_db():
    init_db()
    return {"ok": True, "message": "DB initialized"}

class LoginBody(BaseModel):
    email: str
    password: str

@app.post("/auth/login")
def login(body: LoginBody):
    user = get_user_by_email(body.email.lower())
    if not user or (not verify_password(body.password, user["password_hash"])):
        raise HTTPException(status_code=401, detail="Invalid credentials")
    token = create_access_token({"sub": str(user["id"]), "client_id": user["client_id"]})
    return {"access_token": token, "token_type": "bearer", "user": {
        "id": user["id"], "client_id": user["client_id"], "full_name": user["full_name"],
        "email": user["email"], "role": user["role"]
    }}

@app.get("/me")
def me(authorization: str | None = Header(default=None)):
    if not authorization or not authorization.lower().startswith("bearer "):
        raise HTTPException(status_code=401, detail="Missing bearer token")
    token = authorization.split(" ", 1)[1]
    try:
        data = decode_token(token)
        user_id = int(data["sub"])
    except Exception:
        raise HTTPException(status_code=401, detail="Invalid token")
    user = get_user_by_id(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return {"ok": True, "user": user}

# ----------- ROUTES INTERNES (collector) -----------
@app.get("/collector/bodacc")
def collector_bodacc(token: str = Query(default=""), limit: int = Query(default=8, ge=1, le=50)):
    if token != INTERNAL_TOKEN:
        raise HTTPException(status_code=401, detail="Invalid internal token")
    data = bodacc_collect(limit=limit)
    return {"ok": True, "source": "BODACC", "count": len(data), "items": data}
DB_URL = os.getenv("DB_URL", "postgresql://radar:radarpass@db:5432/radar")

@app.post("/collector/bodacc/ingest")
def collector_bodacc_ingest(token: str = Query(default=""), limit: int = Query(default=8, ge=1, le=50)):
    if token != INTERNAL_TOKEN:
        raise HTTPException(status_code=401, detail="Invalid internal token")

    items = bodacc_collect(limit=limit)
    inserted = 0
    with psycopg.connect(DB_URL, autocommit=True) as conn:
        with conn.cursor() as cur:
            for it in items:
                # 1) Extraire SIREN s'il est présent
                m = re.search(r"(SIREN\s+)?(\d{9})", it["text"])
                siren = m.group(2) if m else None

                # 2) Upsert company (si SIREN détecté)
                company_id = None
                if siren:
                    cur.execute("""
                        insert into company (country, siren, name)
                        values ('FR', %s, coalesce(%s,'Inconnue'))
                        on conflict (siren) do update set updated_at=now()
                        returning id;
                    """, (siren, None))
                    row = cur.fetchone()
                    company_id = row[0] if row else None

                # 3) Classifier le type de signal (MVP)
                txt = it["text"].lower()
                if "redressement judiciaire" in txt or "liquidation judiciaire" in txt:
                    sig_type = "PROC_COLLECTIVE"; weight = 100; conf = 0.95
                elif "cession de fonds" in txt:
                    sig_type = "SALE_OF_BUSINESS"; weight = 70; conf = 0.80
                elif "fusion" in txt:
                    sig_type = "M&A_PROJECT"; weight = 60; conf = 0.70
                else:
                    sig_type = "OTHER"; weight = 30; conf = 0.50

                # 4) Insérer le signal (éviter doublons par URL)
                cur.execute("""
   	 		insert into signal (company_id, source, type, event_date, url, excerpt, weight, confidence)
    			values (%s, 'BODACC', %s, %s, %s, %s, %s, %s)
    			on conflict (url) do update
      				set event_date = excluded.event_date,
          				excerpt    = excluded.excerpt,
          				weight     = excluded.weight,
          				confidence = excluded.confidence,
          				company_id = coalesce(signal.company_id, excluded.company_id),
          				type       = excluded.type;
		""", (
   	 		company_id, sig_type, it["event_date"],
    			it["url"], it["text"], weight, conf
		))

    return {"ok": True, "inserted": inserted, "count_source": len(items)}
from typing import Optional, List, Dict
import psycopg

@app.get("/api/signals")
def api_signals(limit: int = 50):
    limit = max(1, min(limit, 200))
    rows: List[Dict] = []
    with psycopg.connect(DB_URL) as conn:
        with conn.cursor() as cur:
            cur.execute("""
                select
                  s.id,
                  s.company_id,
                  coalesce(c.name, 'Inconnue') as company_name,
                  c.siren,
                  s.type,
                  s.event_date,
                  s.url,
                  s.excerpt,
                  s.weight,
                  s.confidence
                from signal s
                left join company c on c.id = s.company_id
                order by s.event_date desc, s.id desc
                limit %s;
            """, (limit,))
            cols = [d[0] for d in cur.description]
            for r in cur.fetchall():
                rows.append(dict(zip(cols, r)))
    return {"ok": True, "count": len(rows), "items": rows}

# ----------- ADMIN: scoring quotidien -----------
@app.post("/admin/score-daily")
def admin_score_daily(token: str = Query(default=""), date: str | None = Query(default=None)):
    from settings import INTERNAL_TOKEN  # sécurité: lit depuis l'env au runtime
    if token != INTERNAL_TOKEN:
        raise HTTPException(status_code=401, detail="Invalid internal token")
    try:
        if date:
            dt.date.fromisoformat(date)  # YYYY-MM-DD
    except Exception:
        raise HTTPException(status_code=400, detail="Bad date format, expected YYYY-MM-DD")
    n = recompute_daily(date)
    return {"ok": True, "updated_rows": n, "date": date}




@app.get("/api/scores/daily")
def api_scores_daily(date: Optional[str] = None, limit: int = 50):
    """
    Retourne les sociétés scorées pour une date (YYYY-MM-DD).
    Par défaut: aujourd'hui.
    """
    # Normalisation défensive
    if not date:
        date_str = dt.date.today().isoformat()
    else:
        date_str = str(date).strip().strip('"').strip("'")
        if len(date_str) >= 10:
            date_str = date_str[:10]

    # Validation stricte
    try:
        dt.date.fromisoformat(date_str)
    except Exception:
        raise HTTPException(status_code=400, detail="Bad date format, expected YYYY-MM-DD")

    rows: List[Dict] = []
    with psycopg.connect(DB_URL) as conn:
        with conn.cursor() as cur:
            cur.execute("""
                select
                  cs.company_id,
                  coalesce(c.name, 'Inconnue') as company_name,
                  c.siren,
                  cs.score_date,
                  cs.score_total,
                  cs.top_signal_type
                from company_score_daily cs
                left join company c on c.id = cs.company_id
                where cs.score_date = %s::date
                order by cs.score_total desc
                limit %s;
            """, (date_str, limit))
            for (company_id, company_name, siren, score_date, score_total, top_signal_type) in cur.fetchall():
                rows.append({
                    "company_id": company_id,
                    "company_name": company_name,
                    "siren": siren,
                    "score_date": score_date.isoformat(),
                    "score_total": int(score_total),
                    "top_signal_type": top_signal_type,
                })
    return {"ok": True, "date": date_str, "count": len(rows), "items": rows}

@app.get("/api/scores/daily")
def api_scores_daily(date: Optional[str] = None, limit: int = 50):
    """
    Retourne les sociétés scorées pour une date (YYYY-MM-DD).
    Par défaut: aujourd'hui.
    """
    # Normalisation défensive
    if not date:
        date_str = dt.date.today().isoformat()
    else:
        date_str = str(date).strip().strip('"').strip("'")
        if len(date_str) >= 10:
            date_str = date_str[:10]

    # Validation stricte
    try:
        dt.date.fromisoformat(date_str)
    except Exception:
        raise HTTPException(status_code=400, detail="Bad date format, expected YYYY-MM-DD")

    rows: List[Dict] = []
    with psycopg.connect(DB_URL) as conn:
        with conn.cursor() as cur:
            cur.execute("""
                select
                  cs.company_id,
                  coalesce(c.name, 'Inconnue') as company_name,
                  c.siren,
                  cs.score_date,
                  cs.score_total,
                  cs.top_signal_type
                from company_score_daily cs
                left join company c on c.id = cs.company_id
                where cs.score_date = %s::date
                order by cs.score_total desc
                limit %s;
            """, (date_str, limit))
            for (company_id, company_name, siren, score_date, score_total, top_signal_type) in cur.fetchall():
                rows.append({
                    "company_id": company_id,
                    "company_name": company_name,
                    "siren": siren,
                    "score_date": score_date.isoformat(),
                    "score_total": int(score_total),
                    "top_signal_type": top_signal_type,
                })
    return {"ok": True, "date": date_str, "count": len(rows), "items": rows}
from typing import Optional, List, Dict

@app.get("/api/scores/daily")
def api_scores_daily(date: Optional[str] = None, limit: int = 50):
    """
    Retourne les sociétés scorées pour une date (YYYY-MM-DD).
    Par défaut: aujourd'hui.
    """
    # Normalisation défensive
    if not date:
        date_str = dt.date.today().isoformat()
    else:
        date_str = str(date).strip().strip('"').strip("'")
        if len(date_str) >= 10:
            date_str = date_str[:10]

    # Validation stricte
    try:
        dt.date.fromisoformat(date_str)
    except Exception:
        raise HTTPException(status_code=400, detail="Bad date format, expected YYYY-MM-DD")

    rows: List[Dict] = []
    with psycopg.connect(DB_URL) as conn:
        with conn.cursor() as cur:
            cur.execute("""
                select
                  cs.company_id,
                  coalesce(c.name, 'Inconnue') as company_name,
                  c.siren,
                  cs.score_date,
                  cs.score_total,
                  cs.top_signal_type
                from company_score_daily cs
                left join company c on c.id = cs.company_id
                where cs.score_date = %s::date
                order by cs.score_total desc
                limit %s;
            """, (date_str, limit))
            for (company_id, company_name, siren, score_date, score_total, top_signal_type) in cur.fetchall():
                rows.append({
                    "company_id": company_id,
                    "company_name": company_name,
                    "siren": siren,
                    "score_date": score_date.isoformat(),
                    "score_total": int(score_total),
                    "top_signal_type": top_signal_type,
                })
    return {"ok": True, "date": date_str, "count": len(rows), "items": rows}
